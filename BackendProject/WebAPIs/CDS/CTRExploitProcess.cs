using BackendProject.HomeTools.Crypto;
using System.Text;

namespace BackendProject.WebAPIs.CDS
{
    public class CTRExploitProcess
    {
        private static readonly byte[] XMLFirst8BytesHeaderWithJunk = new byte[] { 0xEF, 0xBB, 0xBF, 0x3C, 0x3F, 0x78, 0x6D, 0x6C };
        private static readonly byte[] XMLFirst8BytesHeader = new byte[] { 0x3C, 0x3F, 0x78, 0x6D, 0x6C, 0x20, 0x76, 0x65 };
        private static readonly byte[] XMLFirst8BytesSceneListTag = new byte[] { 0x3C, 0x53, 0x43, 0x45, 0x4E, 0x45, 0x4C, 0x49 };
        private static readonly byte[] XMLFirst4BytesRootTagLittleCase = new byte[] { 0x3C, 0x78, 0x6D, 0x6C };
        private static readonly byte[] XMLFirst4BytesRootTagBigCase = new byte[] { 0x3C, 0x58, 0x4D, 0x4C };
        private static readonly byte[] XMLFirst5BytesRootTag = new byte[] { 0x3C, 0x52, 0x6F, 0x6F, 0x74 };
        private static readonly byte[] BARFirst8BytesBigEndianLeanZlibHeader = new byte[] { 0xAD, 0xEF, 0x17, 0xE1, 0x01, 0x00, 0x00, 0x02 };
        private static readonly byte[] BARFirst8BytesLittleEndianHeader = new byte[] { 0xE1, 0x17, 0xEF, 0xAD, 0x00, 0x00, 0x00, 0x01 };

        public static byte[]? ProcessExploit(byte[] CipherTextReference, byte[] EncryptedFileBytes, int path, bool servermode)
        {
            byte[]? ProcessedFileBytes = null;
            byte[]? GuessedIV = null;

            switch (path)
            {
                case 1: // HCDB
                    ProcessedFileBytes = BruteforceHCDB(CipherTextReference, EncryptedFileBytes, Encoding.UTF8.GetBytes("segs"), servermode);
                    break;
                case 2: // BAR BIG ENDIAN LEANZLIB - as far as we know, CDS had booth little endian without params and big endian leanzlib.
                    GuessedIV = new BlowfishECBEncryptDecrypt().ProcessECBBuffer(MiscUtils.XORBytes(CipherTextReference, BARFirst8BytesBigEndianLeanZlibHeader));
                    if (GuessedIV != null)
                        ProcessedFileBytes = CheckBARResult(EncryptedFileBytes, CipherTextReference, GuessedIV);
                    break;
                default: // XML
                    GuessedIV = new BlowfishECBEncryptDecrypt().ProcessECBBuffer(MiscUtils.XORBytes(CipherTextReference, XMLFirst8BytesHeaderWithJunk));
                    if (GuessedIV != null)
                    {
                        ProcessedFileBytes = CheckAndFindResult(EncryptedFileBytes, GuessedIV, "<?xml version");
                        if (ProcessedFileBytes == null)
                        {
                            GuessedIV = new BlowfishECBEncryptDecrypt().ProcessECBBuffer(MiscUtils.XORBytes(CipherTextReference, XMLFirst8BytesHeader));
                            if (GuessedIV != null)
                            {
                                ProcessedFileBytes = CheckAndFindResult(EncryptedFileBytes, GuessedIV, "<?xml version");
                                if (ProcessedFileBytes == null)
                                {
                                    GuessedIV = new BlowfishECBEncryptDecrypt().ProcessECBBuffer(MiscUtils.XORBytes(CipherTextReference, XMLFirst8BytesSceneListTag));
                                    if (GuessedIV != null)
                                    {
                                        ProcessedFileBytes = CheckAndFindResult(EncryptedFileBytes, GuessedIV, "</SCENELIST>");
                                        if (ProcessedFileBytes == null)
                                        {
                                            ProcessedFileBytes = BruteforceXML(CipherTextReference, EncryptedFileBytes, XMLFirst4BytesRootTagLittleCase, "</xml>", servermode);
                                            if (ProcessedFileBytes == null)
                                            {
                                                ProcessedFileBytes = BruteforceXML(CipherTextReference, EncryptedFileBytes, XMLFirst4BytesRootTagBigCase, "</XML>", servermode);
                                                if (ProcessedFileBytes == null)
                                                    ProcessedFileBytes = BruteforceRootXML(CipherTextReference, EncryptedFileBytes, XMLFirst5BytesRootTag, "</Root>", servermode);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    break;
            }

            return ProcessedFileBytes;
        }

        private static byte[]? BruteforceHCDB(byte[] CipherTextReference, byte[] EncryptedFileBytes, byte[] ReferencePlainTextPart, bool servermode)
        {
            int numofthreads = 2;
            byte[]? OutputValue = null;

            if (!servermode)
                numofthreads = Environment.ProcessorCount;

            Parallel.For(0, 256, new ParallelOptions { MaxDegreeOfParallelism = numofthreads }, i =>
            {
                byte value = (byte)(255 - i);

                if (OutputValue == null)
                {
                    Parallel.For(0, 256, new ParallelOptions { MaxDegreeOfParallelism = numofthreads }, j =>
                    {
                        byte value1 = (byte)(255 - j);

                        if (OutputValue == null)
                        {
                            Parallel.For(0, 256, new ParallelOptions { MaxDegreeOfParallelism = numofthreads }, k =>
                            {
                                byte value2 = (byte)(255 - k);

                                if (OutputValue == null)
                                {
                                    Parallel.For(0, 256, new ParallelOptions { MaxDegreeOfParallelism = numofthreads }, l =>
                                    {
                                        byte value3 = (byte)(255 - l);

                                        if (OutputValue == null)
                                        {

                                            byte[] ReferencePlainText = MiscUtils.CombineByteArray(ReferencePlainTextPart, new byte[] { value, value1, value2, value3 });
#if DEBUG
                                            CustomLogger.LoggerAccessor.LogInfo("[CDS] - BruteforceHCDB - Current PlainText Value - {0}", MiscUtils.ByteArrayToHexString(ReferencePlainText));
#endif
                                            byte[]? GuessedIV = new BlowfishECBEncryptDecrypt().ProcessECBBuffer(MiscUtils.XORBytes(CipherTextReference, ReferencePlainText));

                                            if (GuessedIV != null)
                                            {
                                                byte[]? ProcessedFileBytes = CheckHCDBResult(EncryptedFileBytes, GuessedIV);

                                                if (ProcessedFileBytes != null)
                                                    OutputValue = ProcessedFileBytes;
                                            }
                                        }
                                        else
                                            return;
                                    });
                                }
                                else
                                    return;
                            });
                        }
                        else
                            return;
                    });
                }
                else
                    return;
            });

            return OutputValue;
        }

        private static byte[]? BruteforceXML(byte[] CipherTextReference, byte[] EncryptedFileBytes, byte[] ReferencePlainTextPart, string pathern, bool servermode)
        {
            int numofthreads = 2;
            byte[]? OutputValue = null;

            if (!servermode)
                numofthreads = Environment.ProcessorCount;

            Parallel.For(0, 256, new ParallelOptions { MaxDegreeOfParallelism = numofthreads }, i =>
            {
                byte value = (byte)i;

                if (OutputValue == null)
                {
                    Parallel.For(0, 256, new ParallelOptions { MaxDegreeOfParallelism = numofthreads }, j =>
                    {
                        byte value1 = (byte)j;

                        if (OutputValue == null)
                        {
                            Parallel.For(0, 256, new ParallelOptions { MaxDegreeOfParallelism = numofthreads }, k =>
                            {
                                byte value2 = (byte)k;

                                if (OutputValue == null)
                                {
                                    Parallel.For(0, 256, new ParallelOptions { MaxDegreeOfParallelism = numofthreads }, l =>
                                    {
                                        byte value3 = (byte)l;

                                        if (OutputValue == null)
                                        {
                                            byte[] ReferencePlainText = MiscUtils.CombineByteArray(ReferencePlainTextPart, new byte[] { value, value1, value2, value3 });
#if DEBUG
                                            CustomLogger.LoggerAccessor.LogInfo("[CDS] - BruteforceXML - Current PlainText Value - {0}", MiscUtils.ByteArrayToHexString(ReferencePlainText));
#endif
                                            byte[]? GuessedIV = new BlowfishECBEncryptDecrypt().ProcessECBBuffer(MiscUtils.XORBytes(CipherTextReference, ReferencePlainText));

                                            if (GuessedIV != null)
                                            {
                                                byte[]? ProcessedFileBytes = CheckAndFindResult(EncryptedFileBytes, GuessedIV, pathern);

                                                if (ProcessedFileBytes != null)
                                                    OutputValue = ProcessedFileBytes;
                                            }
                                        }
                                        else
                                            return;
                                    });
                                }
                                else
                                    return;
                            });
                        }
                        else
                            return;
                    });
                }
                else
                    return;
            });

            return OutputValue;
        }

        private static byte[]? BruteforceRootXML(byte[] CipherTextReference, byte[] EncryptedFileBytes, byte[] ReferencePlainTextPart, string pathern, bool servermode)
        {
            int numofthreads = 2;
            byte[]? OutputValue = null;

            if (!servermode)
                numofthreads = Environment.ProcessorCount;

            Parallel.For(0, 256, new ParallelOptions { MaxDegreeOfParallelism = numofthreads }, i =>
            {
                byte value = (byte)i;

                if (OutputValue == null)
                {
                    Parallel.For(0, 256, new ParallelOptions { MaxDegreeOfParallelism = numofthreads }, j =>
                    {
                        byte value1 = (byte)j;

                        if (OutputValue == null)
                        {
                            Parallel.For(0, 256, new ParallelOptions { MaxDegreeOfParallelism = numofthreads }, k =>
                            {
                                byte value2 = (byte)k;

                                if (OutputValue == null)
                                {
                                    byte[] ReferencePlainText = MiscUtils.CombineByteArray(ReferencePlainTextPart, new byte[] { value, value1, value2 });
#if DEBUG
                                    CustomLogger.LoggerAccessor.LogInfo("[CDS] - BruteforceRootXML - Current PlainText Value - {0}", MiscUtils.ByteArrayToHexString(ReferencePlainText));
#endif
                                    byte[]? GuessedIV = new BlowfishECBEncryptDecrypt().ProcessECBBuffer(MiscUtils.XORBytes(CipherTextReference, ReferencePlainText));

                                    if (GuessedIV != null)
                                    {
                                        byte[]? ProcessedFileBytes = CheckAndFindResult(EncryptedFileBytes, GuessedIV, pathern);

                                        if (ProcessedFileBytes != null)
                                            OutputValue = ProcessedFileBytes;
                                    }
                                }
                                else
                                    return;
                            });
                        }
                        else
                            return;
                    });
                }
                else
                    return;
            });

            return OutputValue;
        }

        private static byte[]? CheckAndFindResult(byte[] EncryptedFileBytes, byte[] GuessedIV, string pathern)
        {
            byte[]? TestFileBytes = new BlowfishCTREncryptDecrypt().InitiateCTRBuffer(EncryptedFileBytes, GuessedIV);

            if (TestFileBytes != null && Encoding.UTF8.GetString(TestFileBytes).Contains(pathern))
            {
                CustomLogger.LoggerAccessor.LogInfo("[CDS] - CTRExploitProcess - Valid File was bruteforced! - {0}", DateTime.Now.ToString());
                CustomLogger.LoggerAccessor.LogInfo("[CDS] - CTRExploitProcess - Found IV - {0}", MiscUtils.ByteArrayToHexString(GuessedIV));
                return TestFileBytes;
            }

            return null;
        }

        private static byte[]? CheckHCDBResult(byte[] EncryptedFileBytes, byte[] GuessedIV)
        {
            byte[]? TestFileBytes = new BlowfishCTREncryptDecrypt().InitiateCTRBuffer(EncryptedFileBytes, GuessedIV);

            if (TestFileBytes != null)
            {
                if (new EDGELZMA().Decompress(TestFileBytes, true, false) != null)
                {
                    CustomLogger.LoggerAccessor.LogInfo("[CDS] - CTRExploitProcess - Valid File was bruteforced! - {0}", DateTime.Now.ToString());
                    CustomLogger.LoggerAccessor.LogInfo("[CDS] - CTRExploitProcess - Found IV - {0}", MiscUtils.ByteArrayToHexString(GuessedIV));
                    return TestFileBytes;
                }
            }

            return null;
        }

        private static byte[]? CheckBARResult(byte[] EncryptedFileBytes, byte[] CipherTextReference, byte[]? GuessedIV)
        {
            if (GuessedIV != null)
            {
                byte[]? TestFileBytes = new BlowfishCTREncryptDecrypt().InitiateCTRBuffer(EncryptedFileBytes, GuessedIV);

                if (TestFileBytes != null && TestFileBytes.Length > 12 && MiscUtils.FindbyteSequence(TestFileBytes, new byte[] { 0xAD, 0xEF, 0x17, 0xE1, 0x01, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00 }))
                {
                    CustomLogger.LoggerAccessor.LogInfo("[CDS] - CTRExploitProcess - Valid File was bruteforced! - {0}", DateTime.Now.ToString());
                    CustomLogger.LoggerAccessor.LogInfo("[CDS] - CTRExploitProcess - Found IV - {0}", MiscUtils.ByteArrayToHexString(GuessedIV));
                    return TestFileBytes;
                }
                else
                {
                    GuessedIV = new BlowfishECBEncryptDecrypt().ProcessECBBuffer(MiscUtils.XORBytes(CipherTextReference, BARFirst8BytesLittleEndianHeader));
                    if (GuessedIV != null)
                    {
                        TestFileBytes = new BlowfishCTREncryptDecrypt().InitiateCTRBuffer(EncryptedFileBytes, GuessedIV);

                        if (TestFileBytes != null && TestFileBytes.Length > 12 && MiscUtils.FindbyteSequence(TestFileBytes, new byte[] { 0xE1, 0x17, 0xEF, 0xAD, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00 }))
                        {
                            CustomLogger.LoggerAccessor.LogInfo("[CDS] - CTRExploitProcess - Valid File was bruteforced! - {0}", DateTime.Now.ToString());
                            CustomLogger.LoggerAccessor.LogInfo("[CDS] - CTRExploitProcess - Found IV - {0}", MiscUtils.ByteArrayToHexString(GuessedIV));
                            return TestFileBytes;
                        }
                    }
                }
            }

            return null;
        }
    }
}
