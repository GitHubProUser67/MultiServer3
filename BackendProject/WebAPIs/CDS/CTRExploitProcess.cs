using BackendProject.HomeTools.Crypto;
using System.Text;

namespace BackendProject.WebAPIs.CDS
{
    public class CTRExploitProcess
    {
        private static readonly byte[] XMLFirst8BytesHeader = new byte[] { 0xEF, 0xBB, 0xBF, 0x3C, 0x3F, 0x78, 0x6D, 0x6C };
        private static readonly byte[] XMLFirst8BytesSceneListTag = new byte[] { 0x3C, 0x53, 0x43, 0x45, 0x4E, 0x45, 0x4C, 0x49 };
        private static readonly byte[] XMLFirst4BytesRootTagLittleCase = new byte[] { 0x3C, 0x78, 0x6D, 0x6C };
        private static readonly byte[] XMLFirst4BytesRootTagBigCase = new byte[] { 0x3C, 0x58, 0x4D, 0x4C };
        private static readonly byte[] XMLFirst5BytesRootTag = new byte[] { 0x3C, 0x52, 0x6F, 0x6F, 0x74 };
        private static readonly byte[] BARFirst8BytesLittleEndianHeader = new byte[] { 0xE1, 0x17, 0xEF, 0xAD, 0x00, 0x00, 0x00, 0x01 };
        private static readonly byte[] SHARCFirst8BytesBigEndianHeader = new byte[] { 0xAD, 0xEF, 0x17, 0xE1, 0x02, 0x00, 0x00, 0x00 };
        private static readonly byte[] NPDv4Header = new byte[] { 0x4E, 0x50, 0x44, 0x00, 0x00, 0x00, 0x00, 0x04 };

        public static byte[]? ProcessExploit(byte[] CipherTextReference, byte[] EncryptedFileBytes, int path, bool servermode)
        {
            byte[]? ProcessedFileBytes = null;
            byte[]? GuessedIV = null;

            switch (path)
            {
                case 1: // HCDB
                    ProcessedFileBytes = BruteforceHCDB(CipherTextReference, EncryptedFileBytes, Encoding.UTF8.GetBytes("segs"), servermode);
                    break;
                case 2: // BAR - Doesn't support proper checks (will always return a result).
                    GuessedIV = new BlowfishECBEncryptDecrypt().ProcessECBBuffer(MiscUtils.XORBytes(CipherTextReference, BARFirst8BytesLittleEndianHeader));
                    if (GuessedIV != null)
                        ProcessedFileBytes = CheckAndFindResult(new BlowfishCTREncryptDecrypt().InitiateCTRBuffer(CipherTextReference, GuessedIV),
                                EncryptedFileBytes, GuessedIV, string.Empty);
                    break;
                case 3: // SHARC - Doesn't support proper checks (will always return a result).
                    GuessedIV = new BlowfishECBEncryptDecrypt().ProcessECBBuffer(MiscUtils.XORBytes(CipherTextReference, SHARCFirst8BytesBigEndianHeader));
                    if (GuessedIV != null)
                        ProcessedFileBytes = CheckAndFindResult(new BlowfishCTREncryptDecrypt().InitiateCTRBuffer(CipherTextReference, GuessedIV),
                                EncryptedFileBytes, GuessedIV, string.Empty);
                    break;
                case 4: // SDAT - Doesn't support proper checks (will always return a result).
                    GuessedIV = new BlowfishECBEncryptDecrypt().ProcessECBBuffer(MiscUtils.XORBytes(CipherTextReference, NPDv4Header));
                    if (GuessedIV != null)
                        ProcessedFileBytes = CheckAndFindResult(new BlowfishCTREncryptDecrypt().InitiateCTRBuffer(CipherTextReference, GuessedIV),
                                EncryptedFileBytes, GuessedIV, string.Empty);
                    break;
                default: // XML
                    GuessedIV = new BlowfishECBEncryptDecrypt().ProcessECBBuffer(MiscUtils.XORBytes(CipherTextReference, XMLFirst8BytesHeader));
                    if (GuessedIV != null)
                    {
                        ProcessedFileBytes = CheckAndFindResult(new BlowfishCTREncryptDecrypt().InitiateCTRBuffer(CipherTextReference, GuessedIV),
                            EncryptedFileBytes, GuessedIV, "<?xml version");
                        if (ProcessedFileBytes == null)
                        {
                            GuessedIV = new BlowfishECBEncryptDecrypt().ProcessECBBuffer(MiscUtils.XORBytes(CipherTextReference, XMLFirst8BytesSceneListTag));
                            if (GuessedIV != null)
                            {
                                ProcessedFileBytes = CheckAndFindResult(new BlowfishCTREncryptDecrypt().InitiateCTRBuffer(CipherTextReference, GuessedIV),
                                    EncryptedFileBytes, GuessedIV, "</SCENELIST>");
                                if (ProcessedFileBytes == null)
                                {
                                    ProcessedFileBytes = BruteforceXML(CipherTextReference, EncryptedFileBytes, XMLFirst4BytesRootTagLittleCase, "</xml>", servermode);
                                    if (ProcessedFileBytes == null)
                                    {
                                        ProcessedFileBytes = BruteforceXML(CipherTextReference, EncryptedFileBytes, XMLFirst4BytesRootTagBigCase, "</XML>", servermode);
                                        if (ProcessedFileBytes == null)
                                            ProcessedFileBytes = BruteforceRootXML(CipherTextReference, EncryptedFileBytes, XMLFirst5BytesRootTag, "</Root>", servermode);
                                    }
                                }
                            }
                        }
                    }
                    break;
            }

            return ProcessedFileBytes;
        }

        private static byte[]? BruteforceHCDB(byte[] CipherTextReference, byte[] EncryptedFileBytes, byte[] ReferencePlainTextPart, bool servermode)
        {
            int numofthreads = 2;
            byte[]? OutputValue = null;

            if (!servermode)
                numofthreads = Environment.ProcessorCount;

            Parallel.For(0, 256, new ParallelOptions { MaxDegreeOfParallelism = numofthreads }, i =>
            {
                byte value = (byte)(255 - i);

                if (OutputValue == null)
                {
                    Parallel.For(0, 256, new ParallelOptions { MaxDegreeOfParallelism = numofthreads }, j =>
                    {
                        byte value1 = (byte)(255 - j);

                        if (OutputValue == null)
                        {
                            Parallel.For(0, 256, new ParallelOptions { MaxDegreeOfParallelism = numofthreads }, k =>
                            {
                                byte value2 = (byte)(255 - k);

                                if (OutputValue == null)
                                {
                                    Parallel.For(0, 256, new ParallelOptions { MaxDegreeOfParallelism = numofthreads }, l =>
                                    {
                                        byte value3 = (byte)(255 - l);

                                        if (OutputValue == null)
                                        {

                                            byte[] ReferencePlainText = MiscUtils.CombineByteArray(ReferencePlainTextPart, new byte[] { value, value1, value2, value3 });
#if DEBUG
                                            CustomLogger.LoggerAccessor.LogInfo("[CDS] - BruteforceHCDB - Current PlainText Value - {0}", MiscUtils.ByteArrayToHexString(ReferencePlainText));
#endif
                                            byte[]? GuessedIV = new BlowfishECBEncryptDecrypt().ProcessECBBuffer(MiscUtils.XORBytes(CipherTextReference, ReferencePlainText));

                                            if (GuessedIV != null)
                                            {
                                                byte[]? ProcessedFileBytes = CheckHCDBResult(new BlowfishCTREncryptDecrypt().InitiateCTRBuffer(CipherTextReference, GuessedIV), EncryptedFileBytes,
                                                    GuessedIV);

                                                if (ProcessedFileBytes != null)
                                                    OutputValue = ProcessedFileBytes;
                                            }
                                        }
                                        else
                                            return;
                                    });
                                }
                                else
                                    return;
                            });
                        }
                        else
                            return;
                    });
                }
                else
                    return;
            });

            return OutputValue;
        }

        private static byte[]? BruteforceXML(byte[] CipherTextReference, byte[] EncryptedFileBytes, byte[] ReferencePlainTextPart, string pathern, bool servermode)
        {
            int numofthreads = 2;
            byte[]? OutputValue = null;

            if (!servermode)
                numofthreads = Environment.ProcessorCount;

            Parallel.For(0, 256, new ParallelOptions { MaxDegreeOfParallelism = numofthreads }, i =>
            {
                byte value = (byte)i;

                if (OutputValue == null)
                {
                    Parallel.For(0, 256, new ParallelOptions { MaxDegreeOfParallelism = numofthreads }, j =>
                    {
                        byte value1 = (byte)j;

                        if (OutputValue == null)
                        {
                            Parallel.For(0, 256, new ParallelOptions { MaxDegreeOfParallelism = numofthreads }, k =>
                            {
                                byte value2 = (byte)k;

                                if (OutputValue == null)
                                {
                                    Parallel.For(0, 256, new ParallelOptions { MaxDegreeOfParallelism = numofthreads }, l =>
                                    {
                                        byte value3 = (byte)l;

                                        if (OutputValue == null)
                                        {
                                            byte[] ReferencePlainText = MiscUtils.CombineByteArray(ReferencePlainTextPart, new byte[] { value, value1, value2, value3 });
#if DEBUG
                                            CustomLogger.LoggerAccessor.LogInfo("[CDS] - BruteforceXML - Current PlainText Value - {0}", MiscUtils.ByteArrayToHexString(ReferencePlainText));
#endif
                                            byte[]? GuessedIV = new BlowfishECBEncryptDecrypt().ProcessECBBuffer(MiscUtils.XORBytes(CipherTextReference, ReferencePlainText));

                                            if (GuessedIV != null)
                                            {
                                                byte[]? ProcessedFileBytes = CheckAndFindResult(new BlowfishCTREncryptDecrypt().InitiateCTRBuffer(CipherTextReference, GuessedIV), EncryptedFileBytes,
                                                    GuessedIV, pathern);

                                                if (ProcessedFileBytes != null)
                                                    OutputValue = ProcessedFileBytes;
                                            }
                                        }
                                        else
                                            return;
                                    });
                                }
                                else
                                    return;
                            });
                        }
                        else
                            return;
                    });
                }
                else
                    return;
            });

            return OutputValue;
        }

        private static byte[]? BruteforceRootXML(byte[] CipherTextReference, byte[] EncryptedFileBytes, byte[] ReferencePlainTextPart, string pathern, bool servermode)
        {
            int numofthreads = 2;
            byte[]? OutputValue = null;

            if (!servermode)
                numofthreads = Environment.ProcessorCount;

            Parallel.For(0, 256, new ParallelOptions { MaxDegreeOfParallelism = numofthreads }, i =>
            {
                byte value = (byte)i;

                if (OutputValue == null)
                {
                    Parallel.For(0, 256, new ParallelOptions { MaxDegreeOfParallelism = numofthreads }, j =>
                    {
                        byte value1 = (byte)j;

                        if (OutputValue == null)
                        {
                            Parallel.For(0, 256, new ParallelOptions { MaxDegreeOfParallelism = numofthreads }, k =>
                            {
                                byte value2 = (byte)k;

                                if (OutputValue == null)
                                {
                                    byte[] ReferencePlainText = MiscUtils.CombineByteArray(ReferencePlainTextPart, new byte[] { value, value1, value2 });
#if DEBUG
                                    CustomLogger.LoggerAccessor.LogInfo("[CDS] - BruteforceRootXML - Current PlainText Value - {0}", MiscUtils.ByteArrayToHexString(ReferencePlainText));
#endif
                                    byte[]? GuessedIV = new BlowfishECBEncryptDecrypt().ProcessECBBuffer(MiscUtils.XORBytes(CipherTextReference, ReferencePlainText));

                                    if (GuessedIV != null)
                                    {
                                        byte[]? ProcessedFileBytes = CheckAndFindResult(new BlowfishCTREncryptDecrypt().InitiateCTRBuffer(CipherTextReference, GuessedIV), EncryptedFileBytes,
                                            GuessedIV, pathern);

                                        if (ProcessedFileBytes != null)
                                            OutputValue = ProcessedFileBytes;
                                    }
                                }
                                else
                                    return;
                            });
                        }
                        else
                            return;
                    });
                }
                else
                    return;
            });

            return OutputValue;
        }

        private static byte[]? CheckAndFindResult(byte[]? ProcessedFileBytes, byte[] EncryptedFileBytes, byte[] GuessedIV, string pathern)
        {
            if (ProcessedFileBytes != null)
            {
                byte[]? TestFileBytes = new BlowfishCTREncryptDecrypt().InitiateCTRBuffer(EncryptedFileBytes, GuessedIV);

                if (TestFileBytes != null)
                {
                    if (!string.IsNullOrEmpty(pathern))
                    {
                        if (Encoding.UTF8.GetString(TestFileBytes).Contains(pathern))
                        {
                            CustomLogger.LoggerAccessor.LogInfo("[CDS] - CTRExploitProcess - Valid File was bruteforced! - {0}", DateTime.Now.ToString());
                            CustomLogger.LoggerAccessor.LogInfo("[CDS] - CTRExploitProcess - Found IV - {0}", MiscUtils.ByteArrayToHexString(GuessedIV));
                            return TestFileBytes;
                        }
                    }
                    else
                    {
                        CustomLogger.LoggerAccessor.LogWarn("[CDS] - CTRExploitProcess - File checking is disabled, check your output - {0}", DateTime.Now.ToString());
                        CustomLogger.LoggerAccessor.LogWarn("[CDS] - CTRExploitProcess - Potential Found IV - {0}", MiscUtils.ByteArrayToHexString(GuessedIV));
                        return TestFileBytes;
                    }
                }
            }

            return null;
        }

        private static byte[]? CheckHCDBResult(byte[]? ProcessedFileBytes, byte[] EncryptedFileBytes, byte[] GuessedIV)
        {
            if (ProcessedFileBytes != null)
            {
                byte[]? TestFileBytes = new BlowfishCTREncryptDecrypt().InitiateCTRBuffer(EncryptedFileBytes, GuessedIV);

                if (TestFileBytes != null)
                {
                    if (new EDGELZMA().Decompress(TestFileBytes, true, false) != null)
                    {
                        CustomLogger.LoggerAccessor.LogInfo("[CDS] - CTRExploitProcess - Valid File was bruteforced! - {0}", DateTime.Now.ToString());
                        CustomLogger.LoggerAccessor.LogInfo("[CDS] - CTRExploitProcess - Found IV - {0}", MiscUtils.ByteArrayToHexString(GuessedIV));
                        return TestFileBytes;
                    }
                }
            }

            return null;
        }
    }
}
