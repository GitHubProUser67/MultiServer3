using CastleLibrary.Utils.Blowfish;
using CyberBackendLibrary.Crypto;
using CyberBackendLibrary.DataTypes;
using HomeTools.Crypto;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace WebAPIService.CDS
{
    public class CTRExploitProcess
    {
        private static readonly byte[] XMLFirst8BytesHeaderWithJunk = new byte[] { 0xEF, 0xBB, 0xBF, 0x3C, 0x3F, 0x78, 0x6D, 0x6C };
        private static readonly byte[] XMLFirst8BytesHeader = new byte[] { 0x3C, 0x3F, 0x78, 0x6D, 0x6C, 0x20, 0x76, 0x65 };
        private static readonly byte[] XMLFirst8BytesSceneListTag = new byte[] { 0x3C, 0x53, 0x43, 0x45, 0x4E, 0x45, 0x4C, 0x49 };
        private static readonly byte[] BARFirst8BytesBigEndianLeanZlibHeader = new byte[] { 0xAD, 0xEF, 0x17, 0xE1, 0x01, 0x00, 0x00, 0x02 };
        private static readonly byte[] BARFirst8BytesLittleEndianLeanZlibHeader = new byte[] { 0xE1, 0x17, 0xEF, 0xAD, 0x02, 0x00, 0x00, 0x01 };
        private static readonly byte[] BARFirst8BytesLittleEndianHeader = new byte[] { 0xE1, 0x17, 0xEF, 0xAD, 0x00, 0x00, 0x00, 0x01 };
        private static readonly byte[] BARFirst8BytesBigEndianEquivHeader = new byte[] { 0xAD, 0xEF, 0x17, 0xE1, 0x01, 0x00, 0x00, 0x01 };
        private static readonly byte[] BARFirst8BytesLittleEndianEquivHeader = new byte[] { 0xE1, 0x17, 0xEF, 0xAD, 0x01, 0x00, 0x00, 0x01 };
        private static readonly byte[] XMLFirst8BytesHeaderNAV1 = new byte[] { 0x3C, 0x58, 0x4D, 0x4C, 0x3E, 0x0D, 0x0A, 0x20 };
        private static readonly byte[] XMLFirst8BytesHeaderNAV2 = new byte[] { 0x3C, 0x58, 0x4D, 0x4C, 0x3E, 0x0A, 0x20, 0x20 };
        private static readonly byte[] First6BytesHCDB = new byte[] { 0x73, 0x65, 0x67, 0x73, 0x01, 0x05 };
        private static readonly List<string> xmlpaterns = new List<string>() { "</SCENELIST>", "<SCENE ID=", "<SDC_VERSION>", "</xml>", "</XML>", "</odc>", "</ODC>" };

        public static byte[]? ProcessExploit(byte[] CipherTextReference, byte[] EncryptedFileBytes, int mode)
        {
            byte[]? ProcessedFileBytes = null;
            byte[]? GuessedIV = null;

            switch (mode)
            {
                case 1: // HCDB
                    ProcessedFileBytes = BruteforceHCDB(CipherTextReference, EncryptedFileBytes, First6BytesHCDB);
                    break;
                case 2: // BAR.
                    GuessedIV = BlowfishECBDecrypt.ProcessECBBuffer(XORBytes(CipherTextReference, BARFirst8BytesBigEndianLeanZlibHeader), ToolsImpl.DefaultKey);
                    if (GuessedIV != null)
                        ProcessedFileBytes = CheckBARResult(EncryptedFileBytes, CipherTextReference, GuessedIV);
                    break;
                default: // XML
                    foreach (byte[] header in new byte[][] { XMLFirst8BytesHeaderWithJunk, XMLFirst8BytesHeader, XMLFirst8BytesSceneListTag, XMLFirst8BytesHeaderNAV1, XMLFirst8BytesHeaderNAV2 })
                    {
                        GuessedIV = BlowfishECBDecrypt.ProcessECBBuffer(XORBytes(CipherTextReference, header), ToolsImpl.DefaultKey);
                        if (GuessedIV != null)
                        {
                            ProcessedFileBytes = CheckAndFindResult(EncryptedFileBytes, GuessedIV);
                            if (ProcessedFileBytes != null)
                                break;
                        }
                    }

                    break;
            }

            return ProcessedFileBytes;
        }

        // Be carefull at each .NET updates, for some reasons the resulted assembly is sensitive in this area.
        private static byte[]? BruteforceHCDB(byte[] CipherTextReference, byte[] EncryptedFileBytes, byte[] ReferencePlainTextPart)
        {
            for (byte value = 0; value <= 255; value++)
            {
                for (byte value1 = 0; value1 <= 255; value1++)
                {
                    byte[] ReferencePlainText = DataTypesUtils.CombineByteArray(ReferencePlainTextPart, new byte[] { value, value1 });
#if DEBUG
                    CustomLogger.LoggerAccessor.LogInfo("[CDS] - BruteforceHCDB - Current PlainText Value - {0}", DataTypesUtils.ByteArrayToHexString(ReferencePlainText));
#endif
                    byte[]? GuessedIV = BlowfishECBDecrypt.ProcessECBBuffer(XORBytes(CipherTextReference, ReferencePlainText), ToolsImpl.DefaultKey);

                    if (GuessedIV != null)
                    {
                        byte[]? ProcessedFileBytes = CheckHCDBResult(EncryptedFileBytes, GuessedIV);

                        if (ProcessedFileBytes != null)
                            return ProcessedFileBytes;
                    }

                    if (value1 == 255) // We break loop when reaching max allowed loop count.
                        break;
                }

                if (value == 255) // We break loop when reaching max allowed loop count.
                    break;
            }

            return null;
        }

        private static byte[]? CheckAndFindResult(byte[] EncryptedFileBytes, byte[] GuessedIV)
        {
            byte[]? TestFileBytes = LIBSECURE.InitiateBlowfishBuffer(EncryptedFileBytes, ToolsImpl.DefaultKey, GuessedIV, "CTR");

            if (TestFileBytes != null)
            {
                foreach (string patern in xmlpaterns)
                {
                    if (Encoding.UTF8.GetString(TestFileBytes).Contains(patern))
                    {
                        CustomLogger.LoggerAccessor.LogInfo("[CDS] - CTRExploitProcess - Valid File was bruteforced! - {0}", DateTime.Now.ToString());
                        CustomLogger.LoggerAccessor.LogInfo("[CDS] - CTRExploitProcess - Found IV - {0}", DataTypesUtils.ByteArrayToHexString(GuessedIV));
                        return TestFileBytes;
                    }
                }
            }

            return null;
        }

        private static byte[]? CheckHCDBResult(byte[] EncryptedFileBytes, byte[] GuessedIV)
        {
            byte[]? TestFileBytes = LIBSECURE.InitiateBlowfishBuffer(EncryptedFileBytes, ToolsImpl.DefaultKey, GuessedIV, "CTR");

            if (TestFileBytes != null)
            {
                if (CompressionLibrary.Utils.EdgeLZMA.Decompress(TestFileBytes, true, false) != null)
                {
                    CustomLogger.LoggerAccessor.LogInfo("[CDS] - CTRExploitProcess - Valid File was bruteforced! - {0}", DateTime.Now.ToString());
                    CustomLogger.LoggerAccessor.LogInfo("[CDS] - CTRExploitProcess - Found IV - {0}", DataTypesUtils.ByteArrayToHexString(GuessedIV));
                    return TestFileBytes;
                }
            }

            return null;
        }

        private static byte[]? CheckBARResult(byte[] EncryptedFileBytes, byte[] CipherTextReference, byte[]? GuessedIV)
        {
            if (GuessedIV != null)
            {
                byte[]? TestFileBytes = LIBSECURE.InitiateBlowfishBuffer(EncryptedFileBytes, ToolsImpl.DefaultKey, GuessedIV, "CTR");

                if (TestFileBytes != null && TestFileBytes.Length > 12 && DataTypesUtils.FindBytePattern(TestFileBytes, new byte[] { 0xAD, 0xEF, 0x17, 0xE1, 0x01, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00 }) != -1)
                {
                    CustomLogger.LoggerAccessor.LogInfo("[CDS] - CTRExploitProcess - Valid File was bruteforced! - {0}", DateTime.Now.ToString());
                    CustomLogger.LoggerAccessor.LogInfo("[CDS] - CTRExploitProcess - Found IV - {0}", DataTypesUtils.ByteArrayToHexString(GuessedIV));
                    return TestFileBytes;
                }
                else
                {
                    GuessedIV = BlowfishECBDecrypt.ProcessECBBuffer(XORBytes(CipherTextReference, BARFirst8BytesLittleEndianHeader), ToolsImpl.DefaultKey);
                    if (GuessedIV != null)
                    {
                        TestFileBytes = LIBSECURE.InitiateBlowfishBuffer(EncryptedFileBytes, ToolsImpl.DefaultKey, GuessedIV, "CTR");

                        if (TestFileBytes != null && TestFileBytes.Length > 12 && DataTypesUtils.FindBytePattern(TestFileBytes, new byte[] { 0xE1, 0x17, 0xEF, 0xAD, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00 }) != -1)
                        {
                            CustomLogger.LoggerAccessor.LogInfo("[CDS] - CTRExploitProcess - Valid File was bruteforced! - {0}", DateTime.Now.ToString());
                            CustomLogger.LoggerAccessor.LogInfo("[CDS] - CTRExploitProcess - Found IV - {0}", DataTypesUtils.ByteArrayToHexString(GuessedIV));
                            return TestFileBytes;
                        }
                        else
                        {
                            GuessedIV = BlowfishECBDecrypt.ProcessECBBuffer(XORBytes(CipherTextReference, BARFirst8BytesBigEndianEquivHeader), ToolsImpl.DefaultKey);
                            if (GuessedIV != null)
                            {
                                TestFileBytes = LIBSECURE.InitiateBlowfishBuffer(EncryptedFileBytes, ToolsImpl.DefaultKey, GuessedIV, "CTR");

                                if (TestFileBytes != null && TestFileBytes.Length > 12 && DataTypesUtils.FindBytePattern(TestFileBytes, new byte[] { 0xAD, 0xEF, 0x17, 0xE1, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00 }) != 1)
                                {
                                    CustomLogger.LoggerAccessor.LogInfo("[CDS] - CTRExploitProcess - Valid File was bruteforced! - {0}", DateTime.Now.ToString());
                                    CustomLogger.LoggerAccessor.LogInfo("[CDS] - CTRExploitProcess - Found IV - {0}", DataTypesUtils.ByteArrayToHexString(GuessedIV));
                                    return TestFileBytes;
                                }
                                else
                                {
                                    GuessedIV = BlowfishECBDecrypt.ProcessECBBuffer(XORBytes(CipherTextReference, BARFirst8BytesLittleEndianEquivHeader), ToolsImpl.DefaultKey);
                                    if (GuessedIV != null)
                                    {
                                        TestFileBytes = LIBSECURE.InitiateBlowfishBuffer(EncryptedFileBytes, ToolsImpl.DefaultKey, GuessedIV, "CTR");

                                        if (TestFileBytes != null && TestFileBytes.Length > 12 && DataTypesUtils.FindBytePattern(TestFileBytes, new byte[] { 0xE1, 0x17, 0xEF, 0xAD, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00 }) != -1)
                                        {
                                            CustomLogger.LoggerAccessor.LogInfo("[CDS] - CTRExploitProcess - Valid File was bruteforced! - {0}", DateTime.Now.ToString());
                                            CustomLogger.LoggerAccessor.LogInfo("[CDS] - CTRExploitProcess - Found IV - {0}", DataTypesUtils.ByteArrayToHexString(GuessedIV));
                                            return TestFileBytes;
                                        }
                                        else
                                        {
                                            GuessedIV = BlowfishECBDecrypt.ProcessECBBuffer(XORBytes(CipherTextReference, BARFirst8BytesLittleEndianLeanZlibHeader), ToolsImpl.DefaultKey);
                                            if (GuessedIV != null)
                                            {
                                                TestFileBytes = LIBSECURE.InitiateBlowfishBuffer(EncryptedFileBytes, ToolsImpl.DefaultKey, GuessedIV, "CTR");

                                                if (TestFileBytes != null && TestFileBytes.Length > 12 && DataTypesUtils.FindBytePattern(TestFileBytes, new byte[] { 0xE1, 0x17, 0xEF, 0xAD, 0x02, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00 }) != -1)
                                                {
                                                    CustomLogger.LoggerAccessor.LogInfo("[CDS] - CTRExploitProcess - Valid File was bruteforced! - {0}", DateTime.Now.ToString());
                                                    CustomLogger.LoggerAccessor.LogInfo("[CDS] - CTRExploitProcess - Found IV - {0}", DataTypesUtils.ByteArrayToHexString(GuessedIV));
                                                    return TestFileBytes;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }

            return null;
        }

        /// <summary>
        /// Apply a XOR mathematical calculation between 2 byte arrays.
        /// <para>Applique un calcul mathï¿½matique de type OU exclusif entre 2 tableaux de bytes.</para>
        /// </summary>
        /// <param name="array1">The left array.</param>
        /// <param name="array2">The right array.</param>
        /// <returns>A byte array.</returns>
        private static byte[] XORBytes(byte[] array1, byte[] array2)
        {
            return array1.Zip(array2, (x, y) => (byte)(x ^ y)).ToArray();
        }
    }
}
